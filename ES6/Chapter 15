Generator函数的语法
  基本概念:可把它理解成一个状态机,封装了多个内部状态,执行Generator函数会返回一个遍历器对象,即Generator函数除了状态机还是一个遍历器对象生成函数,返回的
          遍历器对象可以依次遍历Generator函数内部的每一个状态,而形式上Generator函数是一个普通函数,但其function关键字与函数名之间有一个星号,而且函数体
          内部使用yield表达式来定义不同的内部状态,Generator函数(function *foo(x, y) { ··· })的调用方法与普通函数一样也是在函数名后面加上一对圆括号,
          但调用Generator函数后函数不执行,返回的也不是函数运行结果,而是一个指向内部状态的指针对象,即遍历器对象,然后必须调用遍历器对象的next方法使得指针
          移向下一个状态,即每次调用next方法,内部指针就从函数头部或上一次停下来的地方开始执行直到遇到下一个yield表达式(或return)为止。所以Generator函数
          是分段执行的,而yield表达式是暂停执行的标记,而next方法可以恢复执行.
  yield表达式:yield表达式是暂停标志,但yield表达式后面的表达式只有当调用next方法、内部指针指向该语句时才会执行,因此等于为JS提供了手动的"惰性求值"的语法
             功能,Generator函数也可不用yield表达式,变成了一个单纯的暂缓执行函数,若yield表达式如果用在另一个表达式之中,必须放在圆括号里面,yield表达式
             用作函数参数或放在赋值表达式的右边时可以不加括号.
  与Iterator接口的关系:因为Generator函数就是遍历器生成函数,因此可以把Generator赋值给对象的Symbol.iterator属性从而使得该对象具有Iterator接口,Generator
                      函数执行后返回一个遍历器对象,该对象本身也具有Symbol.iterator属性,执行后返回自身.
  next方法的参数:yield表达式本身没有返回值,或者说总是返回undefined,而next方法可以带一个参数,该参数就会被当作上一个yield表达式的返回值,即通过next方法的
                参数在Generator 函数开始运行之后继续向函数体内部注入值,可以在Generator函数运行的不同阶段从外部向内部注入不同的值,从而调整函数行为.
