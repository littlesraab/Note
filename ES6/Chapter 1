let 和 conset 命令
  
  let命令:1.类似 var 命令(声明变量),但只在其所在的代码块内(即{})有效.
          2.不存在变量提升现象,即变量可以在声明之前使用值为undefined.
          3.在同一作用域内不能重复声明同一变量,所以不能在函数内部重新声明参数.
          
  conset 命令:1.类似 var 命令(声明变量),但声明的是一个只读常量,其值一旦声明就不能被改变,即一旦声明就要被初始化(赋值).
              2.只在所在的代码块内有效,也同样无变量提升.
              3.本质是保证其不变的因为变量的指向的内存地址不能被改变,所以其不能控制复合类型的数据(对象),因为不能控制其它指向的数据结构是否可变,但可用
              object.freeze()应对.
              
  暂时性死区:let 和 conset 命令都存在暂时性死区(TDZ)，即在当前的作用域内,要用到的变量要等到声明变量的那行代码出现后才能获取和使用该变量,否则会报错,且
            在同一作用域内不能重复声明.
            
  ES6块级作用域:一个“{ }”为一个块,而块级作用域可以任意嵌套,外层作用域不能读取内层作用域,内层作用域可声明外层作用域的同名变量,且在块级作用域内应尽量避免
               使用函数声明,容易发生错误,尽量使用函数表达式.  
               
  do表达式:块级作用域本质上是一个语句,把多个操作封装在里面,无返回值,而把都加在块级作用域前,使其变成do表达式,可以返回值(即 let x = do{...}).
  
  顶层对象:在浏览器环境指的是window对象,在 Node 指的是global对象,ES6规定 var 和 function 命令声明的全局变量依然是顶层对象的属性,但let、conset 和 
          class 命令声明的全局变量不是.
