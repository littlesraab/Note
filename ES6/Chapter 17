Class的继承
  简介:1.Class可以通过extends关键字实现继承(例:class ColorPoint extends Point { }).
       2.子类必须在constructor方法中调用super方法,否则新建实例时会报错,这是因为子类是继承父类的this对象然后对其进行加工,如果不调用super方法子类就得不
         到this对象.
       3.ES5的继承是先创造子类的实例对象this,然后再将父类的方法添加到this上面,ES6的继承机制是先创造父类的实例对象this(所以必须先调用super方法),然后再
         用子类的构造函数修改this
       4.如果子类没有定义constructor方法,这个方法会被默认添加,在子类的构造函数中,只有调用super之后才可以使用this关键字,否则会报错,因为子类实例的构建是
         基于对父类实例加工,只有super方法才能返回父类实例,父类的静态方法也会被子类继承.
         
  Object.getPrototypeOf():可以用来从子类上获取父类,可以使用这个方法判断一个类是否继承了另一个类.
  
  super关键字:1.super这个关键字,既可以当作函数使用,也可以当作对象使用.
              2.super作为函数调用时代表父类的构造函数,ES6要求子类的构造函数必须执行一次super函数,而super()内部的this指向的是子类的实例,作为函数时
                super()只能用在子类的构造函数之中,用在其他地方就会报错.
              3.super作为对象时,在普通方法中指向父类的原型对象,在静态方法中指向父类,由于super指向父类的原型对象,所以定义在父类实例上的方法或属性是无法
                通过super调用的.
              4.如果属性定义在父类的原型对象上,super就可以取到,ES6规定通过super调用父类的方法时,方法内部的this指向子类,由于this指向子类,所以如果通过
                super对某个属性赋值,这时super就是this,赋值的属性会变成子类实例的属性.
              5.如果super作为对象用在静态方法之中,这时super将指向父类而不是父类的原型对象,使用super的时必须显式指定是作为函数、还是作为对象使用,否则会
                报错,由于对象总是继承其他对象的,所以可以在任意一个对象中使用super关键字.
                
  类的prototype属性和__proto__属性:1.Class作为构造函数的语法糖,同时有prototype属性和__proto__属性.
                                  2.子类的__proto__属性表示构造函数的继承,总是指向父类.
                                  3.子类prototype属性的__proto__属性表示方法的继承,总是指向父类的prototype属性.
                                  4.这两条继承链可理解为,作为一个对象,子类的原型(__proto__属性)是父类,作为一个构造函数,子类的原型对象(prototype属性)
                                    是父类的原型对象(prototype属性)的实例.
                                    
  extends的继承目标:1.extends关键字后面可以跟多种类型的值,父类只要是一个有prototype属性的函数,就能被子类继承,由于函数都有prototype属性,因此父类可以是
                     任意函数.
                    2.ES6允许继承原生构造函数定义子类,因为ES6是先新建父类的实例对象this,然后再用子类的构造函数修饰this,使得父类的所有行为都可以继承.
                    3.extends关键字不仅可以用来继承类,还可以用来继承原生的构造函数.
