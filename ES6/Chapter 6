函数的扩展

  函数参数默认值:1.ES6允许设置函数参数的默认值(例:function log(x = 1) {},函数参数x默认值为1).
                2.参数变量是默认声明的,所以在函数内不能用let或const再次声明.
                3.而且在函数参数有默认值时不能用同名函数参数,函数参数默认值是惰性求值,即每次使用都会重新计算.
                4.有默认值的参数应放在参数的尾部.
                5.如果设置了参数的默认值,函数进行声明初始化时,参数会形成一个单独的作用域.等到初始化结束,作用域就会消失,而在不设置参数默认值时不会出现.
  
  rest参数:1.即... + 变量名,用于获取多余的参数,使得不需要argument对象.
           2.rest 参数搭配的变量是一个数组,该变量将多余的参数放入数组中,即rest参数就是一个数组,数组特有的方法都可以使用.
  
  箭头函数:1.ES6允许使用"箭头"(=>)函数(例子:var f = v => v 等于 var f = function(v) { return v; }).
           2.若箭头函数不需要参数或需要多个参数,就使用圆括号代表参数部分(例子:var sum = (num1, num2) => num1 + num2).
           3.若箭头函数的代码块部分多于一条语句,就要用大括号将它们括起来,并且使用return语句返回(例:var sum = (num1, num2) => { return num1 + num2; }),
             而大括号会被认为是代码块,所以返回对象时要在外面加上一个括号.
  
  箭头函数注意点:1.函数体内的this对象是定义时的对象,而不是使用时的对象,即箭头函数内的this为固定不变的,原因是箭头函数根本没有自己的this,导致内部的this就
                  是外层代码块的this.
                2.函数不能用作构造函数.
                3.不可用argument对象(指向外部函数),可用rest参数代替.
                4.不能用yield命令，即箭头函数不能用作Generator函数.
  
  双冒号运算符:1.函数绑定运算符是并排的两个冒号(::),双冒号左边是一个对象,右边是一个函数.
              2.该运算符会自动将左边的对象作为上下文环境(this对象)绑定到右边的函数上面.
              3.如果双冒号左边为空,右边是一个对象的方法,则等于将该方法绑定在该对象上面.
  
  尾调用:1.即某个函数的最后一步是调用另一个函数,尾调用不一定出现在函数尾部,只要是最后一步操作即可.
         2.函数调用会在内存形成一个"调用帧"保存调用位置和内部变量等信息,所有的调用帧形成一个"调用栈",尾调用由于是函数的最后一步操作,所以不需要保留外层函
           数的调用帧,因为调用位置、内部变量等信息都不会再用到了,只要直接用内层函数的调用帧取代外层函数的调用帧就可以了.
         3.只有不再用到外层函数的内部变量,内层函数的调用帧才会取代外层函数的调用帧,否则就无法进行"尾调用优化".
  
  尾递归:1.函数调用自身称为递归,如果尾调用自身就称为尾递归.
         2.尾递归的实现往往需要改写递归函数确保最后一步只调用自身,可把所有用到的内部变量改写成函数的参数,除尾递归函数之外再提供一个正常形式的函数
           (例:function tailFactorial(n, total) {if (n === 1) return total; return tailFactorial(n - 1, n * total);}
               function factorial(n) {return tailFactorial(n, 1);}).
         3.或采用ES6的函数默认值(例:function factorial(n, total = 1) {if (n === 1) return total; return factorial(n - 1, n * total);}).

