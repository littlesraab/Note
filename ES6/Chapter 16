Class的基本语法
  简介:可以看作只是一个语法糖,它的绝大部分功能ES5都可以做到,新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已,
      (class Point {constructor(x, y) {this.x = x; this.y = y;}  toString() {return '(' + this.x + ', ' + this.y + ')';}})可以看到里面有一个
      constructor方法,这就是构造方法,而this关键字则代表实例对象,即ES5的构造函数Point,对应ES6的Point类的构造方法,定义“类”的方法的时候直接把函数定义放
      进去了就可以了,另外方法之间不需要逗号分隔,会报错,ES6的类完全可以看作构造函数的另一种写法,类的数据类型就是函数,类本身就指向构造函数
      (Point === Point.prototype.constructor),类的所有方法都定义在类的prototype属性上面,使用的时候直接对类使用new命令,跟构造函数的用法完全一致,而类
      的所有方法都定义在类的prototype属性上面,在类的实例上面调用方法其实就是调用原型上的方法,而类的内部所有定义的方法都是不可枚举的,这ES5的行为不一致,
      类的属性名也可以采用表达式.
   严格模式:类和模块的内部默认就是严格模式.
   constructor方法:为类的默认方法,通过new命令生成对象实例时自动调用该方法,一个类必须有constructor方法,如果没有显式定义,一个空的constructor方法会被默认
                   添加,constructor方法默认返回实例对象（即this),完全可以指定返回另外一个对象,类必须使用new调用,否则会报错.
   类的实例对象:与ES5一样,实例的属性除非显式定义在其本身(即this对象上),否则都是定义在原型上(即在class上),类的所有实例共享一个原型对象,可以通过实例的
               __proto__属性为"类"添加方法.
   Class表达式:与函数一样,类也可以使用表达式的形式定义(const MyClass = class Me {getClassName() {return Me.name;}};),如果类的内部没用到的话可以省略
              Me.
   不存在变量提升:类不存在变量提升.
   私有方法:可通过将私有方法移出模块,因为模块内部的所有方法都是对外可见的,还有一种方法是利用Symbol值的唯一性,将私有方法的名字命名为一个Symbol值.
   this的指向:类的方法内部如果含有this,它默认指向类的实例,如果将这个方法提取出来单独使用,this会指向该方法运行时所在的环境,从而报错.
   name属性:name属性总是返回紧跟在class关键字后面的类名.
   Class的取值函数(getter)和存值函数(setter):在"类"的内部可以使用get和set关键字,对某个属性设置存值函数和取值函数,拦截该属性的存取行为.
   Class的静态方法:类相当于实例的原型,所有在类中定义的方法都会被实例继承,如果在一个方法前加上static关键字,就表示该方法不会被实例继承而是直接通过类来调用
                  称为"静态方法",如果静态方法包含this关键字,这个this指的是类而不是实例,父类的静态方法可以被子类继承,静态方法也是可以从super对象上调用的.
   Class的静态属性和实例属性:静态属性指的是Class本身的属性,而不是定义在实例对象(this)上的属性.
   new.target属性:该属性一般用在构造函数之中,返回new命令作用于的那个构造函数,如果构造函数不是通过new命令调用的,new.target会返回undefined,因此这个属性
                  可以用来确定构造函数是怎么调用的,Class内部调用new.target返回当前Class,子类继承父类时,new.target会返回子类,在函数外部使用new.target
                  会报错.
